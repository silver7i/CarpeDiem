

### 1. 효율적인 문제 해결 사고방식 (Thinking Process)

문제를 딱 봤을 때, 다음과 같은 순서로 머릿속을 정리해 보세요.

1. **공간 정의**: "내가 놀 판이 얼마나 큰가?" → 10x10이면 매우 작습니다. 리스트 하나로 충분하다는 판단을 합니다.
2. **중첩의 의미 파악**: "보라색이 된다는 건 무엇인가?" → 문제에서 빨강(1)과 파랑(2)을 줬으므로, **'두 조건이 동시에 만족되는 곳'**을 찾는 것입니다.
3. **단일화 (Single Source of Truth)**: 격자를 여러 개 만들면 각 격자를 비교하는 로직(예: `if red[i][j] and blue[i][j]`)이 추가로 필요합니다. 격자 하나에 정보를 누적하면 마지막에 그 격자만 확인하면 되므로 코드가 훨씬 간결해집니다.
4. **제약 조건 확인**: "한 칸에 같은 색이 여러 번 칠해지는가?" → 문제에서 "같은 색의 영역은 겹치지 않는다"는 조건이 있다면, 안심하고 숫자를 더하거나(`+= color`), 비트 연산(`|`)을 쓸 수 있습니다.

---

### 2. 리스트(List) vs 개별 변수(Variables) 할당 기준

`map(int, input().split())`을 쓸 때 어떤 방식이 나을지 고민되시죠? 명확한 기준을 잡아드릴게요.

#### **개별 변수로 받는 게 좋을 때 (`r1, c1, r2, c2, color = ...`)**

* **가독성이 최우선일 때**: `data[0]`보다 `r1`이라는 이름을 쓰는 게 코드를 읽는 사람(또는 미래의 나)에게 훨씬 친절합니다.
* **사용하는 변수가 고정되어 있을 때**: 이번 문제처럼 5개의 값이 온다는 게 확실하다면 하나씩 바인딩하는 게 가공하기 편합니다.
* **계산에 바로 활용할 때**: `range(r1, r2+1)` 처럼 바로 수식에 넣을 때 유리합니다.`

#### **리스트로 받는 게 좋을 때 (`data = list(map(int, input().split()))`)**

* **값의 개수가 유동적일 때**: 몇 개가 들어올지 모르는 데이터를 한꺼번에 처리해야 할 때입니다.
* **반복문 안에서 인덱스로 접근해야 할 때**: 데이터 자체를 루프 돌려야 하는 경우입니다.
* **함수에 인자로 넘길 때**: 여러 값을 묶어서 하나의 덩어리로 전달하고 싶을 때 유용합니다.

> **💡 장씨님을 위한 팁:** 지금처럼 SSAFY에서 푸는 알고리즘 문제는 입력 규격이 엄격하게 정해져 있습니다. 따라서 **개별 변수로 가독성 있게 받는 것**을 기본 습관으로 들이시는 걸 추천해요!

---

### 3. 카운팅 방식의 확장: 리스트, 딕셔너리, 그리고 누적

언급하신 것처럼 카운팅에는 여러 방법이 있고, 문제의 상황에 따라 선택지가 달라집니다.

| 방식 | 추천 상황 | 특징 |
| --- | --- | --- |
| **격자 누적 (현재 방식)** | 좌표나 위치 기반의 중첩을 구할 때 | 직관적이고 2차원 데이터를 다루기 좋음. |
| **리스트 (Counting Sort 방식)** | 데이터의 범위(값)가 작고 연속적일 때 | `count_list[value] += 1` 처럼 인덱스를 활용해 매우 빠름. |
| **딕셔너리 (Hash Map 방식)** | 데이터의 범위가 아주 크거나 불연속적일 때 | 메모리를 아낄 수 있고, 존재하지 않는 키를 다루기 유용함. |

이번 문제처럼 **"최대 한 번씩만 칠해진다"**는 보장이 있다면, `+=` 연산은 단순한 카운팅을 넘어 **상태(State)를 기록하는 도구**가 됩니다. 1(빨강) + 2(파랑) = 3(보라)이라는 논리는 비전공자 트랙에서 '비트마스킹' 개념을 배우기 전 아주 좋은 연습이 될 거예요.
