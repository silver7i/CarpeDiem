
### 🧠 4835번(구간합) 문제를 풀 때의 사고방식 흐름

1. **문제의 본질 파악 (Input & Output)**
* "숫자 뭉텅이가 있고, 거기서 딱 개만 연속으로 골라야 하는구나."
* "그 합들 중에서 제일 큰 놈이랑 제일 작은 놈을 찾아야 하네?"
* "결국 `최댓값 - 최솟값`을 구하는 게 목표군."


2. **구간 정하기 (슬라이딩 윈도우 설계)**
* 숫자가 개 있을 때, 개를 묶으면 첫 번째 묶음은 어디서 시작하지? → 인덱스 `0`
* 마지막 묶음은 어디서 시작해야 번 인덱스를 넘지 않지? → 인덱스 `N - M`
* **결론:** `for i in range(N - M + 1)`로 반복문을 돌리면서 시작점을 하나씩 옆으로 밀어야겠다!


3. **각 구간의 합 구하기**
* 파이썬이니까 복잡하게 `for`문 또 돌리지 말고, 리스트 슬라이싱 `nums[i : i+M]`과 `sum()` 함수를 써서 간단하게 합을 구하자.


4. **비교 및 갱신**
* 지금 구한 합이 내가 지금까지 본 것 중에 제일 큰가? → `max_v` 업데이트
* 지금 구한 합이 내가 지금까지 본 것 중에 제일 작은가? → `min_v` 업데이트


5. **마무리**
* 다 돌았으면 두 값의 차이를 출력하자.



---

### ❓ `float('inf')`가 뭔가요?

결론부터 말씀드리면, **"파이썬에서 표현할 수 있는 가장 큰 양의 실수(무한대)"**를 의미합니다.

#### 1. 왜 무한대를 초기값으로 쓰나요?

최솟값(`min_v`)을 구할 때, 초기값을 `0`으로 설정하면 어떻게 될까요?

* 구간합들이 `10, 20, 30`이라면, `min_v`는 계속 `0`으로 남게 됩니다. (0보다 작은 값이 없으니까요.)
* 그래서 **"어떤 숫자가 들어와도 무조건 그것보다 큰 값"**으로 미리 세팅을 해두는 것입니다. 그래야 첫 번째 구간합이 나오자마자 `min_v`가 그 값으로 갱신될 수 있습니다.

#### 2. 무한대인데 시간 복잡도가 안 올라가나요?

**전혀 올라가지 않습니다.**

* `float('inf')`는 메모리 상에서 아주 큰 숫자를 나타내는 **하나의 상수 값**일 뿐입니다.
* 컴퓨터 입장에서 `min_v = 100`과 비교하는 것이나 `min_v = 무한대`와 비교하는 것이나 **연산 속도는 똑같습니다.** 무한대라고 해서 끝없이 계산을 하는 게 아니라, 단순히 "비교 연산 시 무조건 크다고 판정되는 특수한 숫자"라고 이해하시면 됩니다.

> **💡 꿀팁:** 만약 `float('inf')`가 어색하다면, 문제에서 주어진 조건 중 **최대 가능 합**을 초기값으로 써도 됩니다. 예를 들어 "숫자가 최대 100개이고 각각 최대 10,000이다"라면 `min_v = 1000000`으로 잡아도 무방합니다. 하지만 `float('inf')`가 훨씬 깔끔하고 범용적이죠!
