# [Algorithm/SWEA] 1206. View (조망권 확보 문제)

## 1. 문제 개요

* **문제:** 좌우 2칸(총 4칸) 이내에 나보다 높은 건물이 없으면 '조망권'이 확보된 것으로 간주. 조망권이 확보된 세대의 총 수를 구하라.
* **핵심:** 특정 인덱스()를 기준으로  위치의 건물 높이 중 최댓값을 찾아 비교해야 함.

## 2. 접근 방법 & 로직

* **탐색 범위:** 양 끝 2칸은 건물이 지어지지 않는다고 주어졌으므로, 반복문의 범위를 `range(2, N-2)`로 설정하여 인덱스 에러 방지.
* **비교 로직:**
1. 현재 건물의 높이(`current`)와 주변 4개 건물의 최대 높이(`side_max`)를 구함.
2. `current > side_max`일 경우에만 `current - side_max` 값을 결과(`total_view`)에 누적.



## 3. 나의 분석 및 질문 (Insight)

### Q1. 왜 양 끝 2칸을 0으로 비워뒀을까?

* **나의 생각:** 문제 난이도를 낮추기 위한 장치인 것 같다. 만약 이 조건이 없었다면 인덱스가 `0`보다 작거나 `N`을 넘어가는 경우를 `if`문으로 일일이 예외 처리(Boundary Check) 했어야 했을 것이다.
* **배운 점 (Padding):** 이를 **'패딩(Padding)'** 기법이라고 한다. 데이터의 테두리를 0이나 특정 값으로 감싸서, 복잡한 경계 처리를 없애고 로직을 단순화하는 효율적인 방법이다. (이미지 처리 등에서도 쓰임)

### Q2. 변수 할당의 기준은 무엇인가? (`diff` 변수 유무)

* **관찰:** 코드에서 `current`와 `side_max`는 변수로 미리 선언해서 가독성을 높였는데, 정작 차이값(`current - side_max`)은 별도 변수(`diff`) 없이 바로 더했다.
* **이유:**
* **가독성:** `if`문 조건식에 들어가기 전 의미를 명확히 하기 위해 `current`, `side_max`는 선언함.
* **효율성:** 차이값은 계산 후 누적하고 더 이상 쓰이지 않는 **일회성 값**이므로, 굳이 메모리를 써가며 변수를 만들 필요가 없음.



### Q3. `max()` 함수 vs 반복문

* 최대값이 '무엇'인지 값만 필요할 때는 `max()` 함수가 효율적이고, 최대값의 '인덱스'나 '여러 조건'이 필요할 때는 반복문을 직접 돌리는 것이 적합하다.

## 4. 인상 깊었던 점 (New Learning)

1. **Padding의 미학:** 복잡한 `if`문 범벅이 될 뻔한 코드를, 데이터(입력값)의 구조를 변경함으로써 획기적으로 단순화할 수 있다는 점이 인상적이었다.
2. **Pythonic Code (List Comprehension):**
* 기본 `for`문 코드도 좋지만, 파이썬의 리스트 컴프리헨션을 사용하면 5~6줄의 코드를 단 한 줄로 줄일 수 있다.
* *가독성*과 *간결함* 사이에서 적절한 균형을 찾는 것이 중요함을 느낌.



## 5. 코드 정리

### 1) 가독성을 고려한 기본 풀이 (Standard)

```python
total_view = 0
for i in range(2, N - 2):
    current = buildings[i]
    side_max = max(buildings[i-2], buildings[i-1], buildings[i+1], buildings[i+2])
    
    if current > side_max:
        total_view += current - side_max

```

### 2) 리스트 컴프리헨션을 활용한 풀이 (Pythonic)

```python
# 주변보다 높은 경우에만 그 차이를 리스트로 만들어 합산(sum)
total_view = sum(
    buildings[i] - max(buildings[i-2], buildings[i-1], buildings[i+1], buildings[i+2])
    for i in range(2, N-2)
    if buildings[i] > max(buildings[i-2], buildings[i-1], buildings[i+1], buildings[i+2])
)

```



### 💡 [보충] 리스트 컴프리헨션 vs 제너레이터 표현식

#### 1. 제너레이터 표현식 (Generator Expression)이란?

* **특징:** 대괄호 `[]` 대신 소괄호 `()`를 사용하거나, `sum()`, `max()` 같은 함수의 인자로 바로 사용할 때 활용됨.
* **차이점:** 리스트 컴프리헨션은 모든 결과값을 메모리에 한꺼번에 올리지만, 제너레이터는 **한 번에 하나의 값만 생성**하여 넘겨줌.
* **장점:** 데이터의 양이 아주 많을 때 메모리 사용량을 획기적으로 줄일 수 있음.

#### 2. 문법 구조 (Filtering 포함)

```python
# [계산식 for 변수 in 반복객체 if 조건문]
total_view = sum(current - max_val for i in range(2, N-2) if current > max_val)

```

* **`for`문:** 범위를 지정하며 탐색.
* **`if`절 (Filtering):** 조망권이 확보된(주변보다 높은) 경우만 골라냄.
* **계산식:** 필터링된 항목들에 대해서만 높이 차이를 계산.

#### 3. 왜 여기서 대괄호 `[]`가 없었을까?

* `sum(...)` 함수가 인자로 제너레이터를 받을 수 있기 때문임.
* `sum([리스트])`라고 쓰면 리스트라는 바구니를 새로 만들어야 하지만, `sum(제너레이터)`라고 쓰면 바구니 없이 값만 하나씩 꺼내서 바로 합산함.

---

### 📝 TIL 요약 문구 (복사용)

> **Insight: 효율적인 메모리 관리**
> 단순히 값을 합산(sum)하거나 최댓값(max)을 찾을 때는 리스트 컴프리헨션으로 리스트 객체를 생성하기보다 **제너레이터 표현식**을 사용하는 것이 더 효율적이다. 또한 `for` 뒤에 `if`를 붙여 **원하는 조건의 데이터만 필터링**하여 계산하는 방식은 파이썬다운(Pythonic) 코드 작성의 핵심임을 배웠다.
