## 1. 문제 해결을 위한 사고의 흐름 (Thinking Process)

1. **데이터의 특징 파악:** 카드가 0~9 사이의 숫자로 제한되어 있음  **카운팅 리스트(Counting Array)**가 가장 효율적.
2. **데이터 저장:** 빈 리스트 `[0] * 10`을 만들어 각 숫자의 등장 횟수를 기록.
3. **복합 조건 해결:** "최댓값이 여러 개일 때, 숫자가 더 큰 것을 선택하라"는 조건을 어떻게 로직에 녹일 것인가 고민.

---

## 2. 데이터 저장 방식의 선택

### ① 숫자의 범위가 정해진 경우 (0~9 등)

* **방식:** `List` (인덱스를 숫자로 사용)
* **장점:** 접근 속도가 매우 빠르고 메모리가 효율적임.

### ② 숫자의 범위가 정해지지 않았거나 매우 넓은 경우

* **방식:** `Dictionary` (Key-Value 사용)
* **핵심 문법:** `counts[key] = counts.get(key, 0) + 1`
* `get(key, 0)`: 딕셔너리에 키가 없어도 에러 대신 `0`을 반환하게 하여, 첫 등장 시에도 카운팅이 가능하게 함.



---

## 3. 최댓값과 그 위치(Index)를 찾는 3가지 전략

이 문제의 핵심인 **"장수가 같을 때 더 큰 숫자 카드 선택"**을 해결하는 다양한 방법들입니다.

### 전략 A: 순차 탐색과 등호(`>=`) 활용 (가장 직관적)

0부터 9까지 순서대로 확인하며 최댓값을 갱신할 때, `>` 대신 `>=`를 사용한다.

* **원리:** 0~9 순서로 가기 때문에, 나중에 나타나는(더 큰) 숫자가 기존 최댓값과 **장수가 같더라도** `max_num`을 덮어쓰게 됨.
* **장점:** 별도의 복잡한 `if`문 없이 연산자 하나로 조건 해결.

### 전략 B: 슬라이싱과 뒤집기 (`[::-1]`)

파이썬의 슬라이싱 기능을 이용해 리스트를 거꾸로 탐색한다.

* **원리:** `counts[::-1]`를 통해 리스트를 뒤집은 뒤, 거기서 가장 먼저 나오는 최댓값의 인덱스를 찾음.
* **장점:** "뒤에서부터 찾는다"는 개념을 코드로 직관적으로 구현 가능.
* **주의:** 뒤집힌 리스트의 인덱스를 원래 인덱스로 변환하는 계산(`9 - reversed_idx`)이 필요함.

### 전략 C: 리스트 컴프리헨션(List Comprehension)과 `enumerate`

파이썬의 고급 문법을 활용해 가독성을 높임.

* **코드:** `[i for i, count in enumerate(counts) if count == max_count]`
* **분석:**
* `enumerate(counts)`: (인덱스, 값) 쌍을 하나씩 꺼내줌.
* `if count == max_count`: 최댓값과 일치하는 인덱스들만 필터링.
* 그중 `max()`를 다시 취해 가장 큰 인덱스를 결정.



---

## 4. 새롭게 배운 파이썬 문법 Point

* **`enumerate()`**: 리스트를 돌 때 값뿐만 아니라 **몇 번째(인덱스)**인지도 동시에 필요할 때 사용.
* **슬라이싱 `step` 파라미터**: `counts[start:stop:step]`에서 `step`에 `-1`을 주면 리스트가 뒤집힘.
* **Unpacking**: `for i, count in ...` 처럼 튜플 형태의 데이터를 두 변수로 쪼개서 받는 기법.

---

**💡 Insight:** 비전공 개발자로서 단순히 '답을 내는 코드'를 넘어, **자료구조의 특성(인덱스 순서)을 이용해 조건문(if)을 줄이는 설계**가 얼마나 효율적인지 깨달음. 파이썬의 `get`, `enumerate`, `slicing`은 코드를 간결하게 만들 뿐만 아니라 사고의 폭을 넓혀줌.
