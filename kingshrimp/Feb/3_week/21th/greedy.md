# Greedy
## 개념 및 특징
Greedy Algorithm: 부분, 부분시점에서 매순간 최적의 선택을 하는 알고리즘
최적해를 구하는데 사용하는 근시안적인 방법
각 선택 시점에서 이루어지는 결정은 지역적으로 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고
그것이 최적이라는 보장이 없다.

## 예시
거스름돈 문제(동전이 배수 관계여야한다)
```py
def get_minimum_coins(coin_list, amount):
    result = {}

    for coin in coin_list:
        if amount >= coin:
            coin_count = amount // coin
            amount -= coin_count * coin
            result[coin] = coin_count

    return result

# 큰 동전부터 리스트에 배치
# sort 해도 됨
coins = [500, 100, 50, 10]
change_amount = 1400
change_result = get_minimum_coins(coins, change_amount)

print("거스름돈:", change_amount)

for c, cnt in change_result.items():
    print(f"{c}원 동전: {cnt}개")

```

활용1: 동전 교환
활용2: 배낭 짐싸기
활용3: 활동 선택 문제


## 알고리즘 문제 해결 기법
1. 완전 탐색
2. 탐욕 알고리즘
3. 분할 정복
4. 다이나믹 프로그래밍
추가: BFS, DFS는 완전탐색에 속한다.

일단 완전탐색으로 먼저 풀어보고 아니면 분할정복, 다이나믹 프로그래밍으로 풀고 마지막에 탐욕 알고리즘으로 풀자

왜냐하면 탐욕 알고리즘은 증명하기가 어렵기 때문에 최후의 수단으로 써야한다.

## '전체문제의 정답 = 현재의 최선 + 남은 문제들의 최선'을 증명하면 된다.
탐욕적 선택 속성
현재의 최선이 전체의 최선으로 연결이 되는 안전한 선택이어야한다.

최적 부분 구조
큰 문제는 똑같은 모양의 작은 문제들로 쪼개져 있어야한다.
즉 단계마다 똑같은 규칙을 적용해서 작은 문제들을 해결해 나갈 수 있으면 탐욕 알고리즘으로 접근 할 수 있다.

## 느낀점
가장 인상깊은 부분은 부분, 부분에서의 최적의 선택들을 모은다고 해서 전체를 보았을 때 최적이 되는것은 아니다라는 문구였다.
그리고 일단 브루트포스, 분할정복, 다이나믹 프로그래밍을 시도를 하고 그리디를 선택을 하는것이 좋다라는 문장도 인상이 깊었다.

