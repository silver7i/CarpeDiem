"""
1. 브레인 스토밍
일단 9명을 뽑아서 배열해야한다. 그런데 이미 1명을 뽑아놓은 상태이다.
-> 순서가 있는 배열이니 permutations를 
참고로 product는 중복 순열(주사위 2번던지기)
combination_with_replacement(사과, 배 중에서 3개 고르기)
4번타자에 1번 선수가 들어가야하니깐 순열을 만들고
슬라이싱을 한 이후에 4번자리에 넣어야한다.

한 이닝에 3명이 아웃을 당하면 이닝이 종료가 된다.
따라서 아웃카운트를 따로 기록을 해야한다.
-> for문에 아웃3이면 break를 걸지 아니면 while을 쓸지 고민

다음이닝에 다음 타선이 돌아야하니깐 타선도 기록해야한다.
-> 9명이 회전을 하니깐 %9를 통해서 관리를 해야한다.

점수를 기록을 해야하니깐 루상에 누가 있는지 알아야한다.
총점수도 기록을 해야한다.

최댓값 득점을 찾아야하니 max_val와 재할당 작업을 해야한다.
-> 재할당 작업은 값만 찾으면 되니깐 loop문이 아니라 max함수를
쓰는게 효율적이다.

순열 문제는 DFS로 풀어도 된다.

2. 판단 기준
1) DFS vs 순열
순열이 유리하다. 왜냐하면 가지치기(가지 자르기)가 불가능하기 때문이다.
시뮬레이션 중간에 어 이거 망했네?라고 탐색 종료를 할 수가 없기 때문이다.
그렇기 때문에 어차피 끝까지 가야하는 것이라면 순열로 돌리는것이 코드가 깔끔하다.

2) 비트마스크 vs 리스트
비트마스크가 유리하다.
루상의 주자를 확인을 할 때 리스트로 [1, 1, 1] 이런식으로 할 수도 있지만
메모리를 많이 먹는 이 문제에서 리스트를 줄여야한다.

3) for vs while
3-1) 이닝수 반복문
for문이 유리하다.
이닝수가 정해져있기 때문이다.
3-2) 선수가 등장하는 반복문
while이 유리하다.
반복 횟수가 정해져있으면 for이 유리하지만 아웃카운트에 따라서 달라지므로
while이 유리하다.

억지로 for문을 쓰는경우의 코드, 한 이닝에 들어오는 선수의 수를 100으로 가정해야함
즉 100이상일 때는 에러가 난다. -> 안좋은 코드
```
# 🟢 for문으로 구현은 가능하지만, 조금 어색한 코드
hitter_idx = 0 # 이닝이 바뀌어도 타순을 기억할 외부 변수

for inning in range(N):
    out = 0
    
    # 타자가 한 이닝에 최대 몇 번이나 나올까? 
    # 무한대는 안 되니 넉넉하게 100번 돈다고 가정 (더미 for문)
    for _ in range(100): 
        hitter = lineup[hitter_idx]
        hit_result = player_hits[inning][hitter]
        
        if hit_result == 0:
            out += 1
            
        # 1. 타순을 수동으로 1칸 넘김
        hitter_idx = (hitter_idx + 1) % 9 
        
        # 2. 아웃카운트 확인 후 break
        if out == 3:
            break
```

3. 배운것
3-1. permutations은 print가 안됨
1) situation
- 백준 야구문제중 순열 생성
2) task
- array = permutations(range(1, 9), 8)
3) action
- 재미나이 물어봄
permutations는 바로 리스트를 보여주는게 아니라 제너레이터 객체를
변환을 하기 때문에 print해도 안나옴
- 해결방법
list로 감싸기
4) result
permutations는 list로 감싸자

3-2. tuple로 나왔을 때 리스트로의 변경
반복문을 돌리면서 순열로 뽑은 것들을 하나씩 list로 감싸면 됨.

3-3. 리스트에 중간 값 삽입 방법
.insert매서드를 사용하면 됨.
lineup.insert(3, 0)이런 방식

3-4. 1번타자를 0번 인덱스가 아닌 1번 인덱스로 만드는 방법
인덱스 번호랑 타선 번호랑 다르면 코드를 할 때 헷갈리고 실수가 발생할 것이다.
그러면 0번 인덱스에 쓸모없는 값을 넣는 방법을 쓴다.
예를 들면 player_hits = [[-1] + list(map(int, input().split()))]
참고로 밑에처럼 대괄호를 풀고 쓰면 안된다. 리스트컴프리헨션이므로 안된다.
[-1] + list(map(int, input().split()))
이거까지는 솔직히 할 줄 알았다. 그런데 타선이 9번 다음에 1번이 와야하는 상태여서
%9로 매번 계산을 해야하는데 그러면 0번 인덱스의 쓸데 없는 값이 나오게 된다.
%10을 해도 0번 인덱스 선수가 나오는 문제가 생긴다.
해결책
hitter_idx = (hitter_idx % 9) + 1

"""
import sys
from itertools import permutations

sys.stdin = open('boj-17281-baseball.txt')

N = int(input())

# 8명을 타자를 순열로 뽑자.
array = list(permutations(range(2, 10), 8))
# [-1] * 10은 0이닝을 만들어서 받는 값들은 1이닝부터 시작이 되게하는 방법
player_hits = [[-1] * 10] + [[-1] + list(map(int, input().split())) for _ in range(N)]
max_score = 0

# 1번선수를 4번타자 자리에 넣자
for players in array:
    lineup = [-1] + list(players)
    lineup.insert(4, 1)
    score = 0
    hitter_idx = 1
    out = 0
    
    # 배열된 선수대로 무엇을 쳤는지 생각을 해야함
    # 1이닝에 1번타자에 no.8선수(8번선수라고 하면 분명 헷갈릴것 같아서 no.로 씀)
    # 가 들어왔다라면 8번선수가 1이닝에 무엇을 쳤는지 찾아야함
    # player_hits에 이차원리스트로 어떤 선수가 무엇을 쳤는지 있음
    # 이차원 리스트에 첫 인덱스는 선수 번호, 두번째 인덱스는 이닝이 들어와야함
    # player_hits[선수 넘버][해당 이닝]

    # 이닝은 9이닝이라고 정해져있으므로 while이 아닌 for문
    # 코드를 읽기 쉽게 이닝수는 1부터 시작
    for inning in range(1, N+1):
        # 매이닝이 끝날때마다 out카운트를 리셋해야하므로 for문 아래 out = 0배치
        out = 0
        b1, b2, b3 = 0, 0, 0
        while out < 3:
            # 뭐해야하는지 생각이 안난다.
            # 이럴때는 위에 아이디어 적어둔거를 보자.
            # 선수를 하나씩 보내야한다.
            # 이전이닝에서 나온 선수 다음 선수부터 줘야한다.
            # player_hits[선수 현재위치][inning]
            # 선수 현재위치를 저장할 변수가 필요하다.
            # curr_player라고하자
            # curr_player보다 hitter_idx가 좋아보인다.
            # 인덱스일때는 뒤에 idx를 붙여야 읽기가 좋다.
            # 값일때와 인덱스일때 구분을 해서 인덱스일때만 뒤에 꼭 idx를 붙이자.
            # 선수 타석 순서는 1~9번인데 인덱스는 0~8번인게 너무 불편하다.
            # 분명 문제를 풀다가 헷갈릴 수 있는 포인트인것 같다.
            # 보통같은면 맨안에 [-1] + player_lineup 이런식으로
            # 쓸모 없는 수를 0번인덱스에 배치해서 쓸텐데
            # 이거는 타석이 돌아야해서 %9 또는 %10을 해야한다.
            # 이러면 쓸모없는 0번 인덱스의 값이 타석에 들어오는 문제가 생긴다.
            # 해결책: hitter_idx = (hitter_idx % 9) + 1
            # 9로 나눌때마다 뒤에 1을 추가를 하면 0번 인덱스를 무시할 수 있다.
            # hit라는 변수를 줄거다.lineup[inning][hitter_idx] 이 변수를
            # 매번 쓸 수도 있지만 가독성이 너어어무 별로다.
            # 이렇게 변수를 정리를 해주는게 코드 분석하는데도 빠르게 도와준다.
            player = lineup[hitter_idx]
            hit = player_hits[inning][player]
            # 다음 선수로 인덱스를 바꾸어야한다.
            hitter_idx = (hitter_idx % 9) + 1
            # 쳤는지 안쳤는지 구분을 해서 나누어야한다.
            # 안타, 2루타, 3루타, 홈런, 아웃 다 나누어도 되지만
            # 멋이 나지 않아...
            # 아웃만 나누고 쳤을때는 하나로 묶어서 할려고 했다.
            # AI한테 두개의 장단점을 물어보니
            # 오히려 아웃, 안타, 2루타, 3루타, 홈런을 다 나누는게 좋다라는
            # 예상외의 답변을 받았다.
            # 왜냐하면 이 문제는 시간 초과가 빡빡한데 4개를 나누는게 더 메모리 사용에 좋다.
            # 라는 답변이었다. 그리고 가독성에도 나누는게 더 좋다라는 평이었다.
            # 비트마스크로 루상을 관리를 하고 싶었는데 아직 부족한게 많아서
            # 다른것에 집중을 일단하고 비트마스크는 다른문제에서 써보겠다.
            if hit == 0:
                out += 1
            elif hit == 1:
                score += b3
                b1, b2, b3 = 1, b1, b2  # 기존 1, 2루 주자는 한 칸씩 밀려남
            elif hit == 2:
                score += b2 + b3
                b1, b2, b3 = 0, 1, b1   # 타자는 2루로, 1루 주자는 3루로
            elif hit == 3:
                score += b1 + b2 + b3
                b1, b2, b3 = 0, 0, 1    # 타자만 3루에 남음
            elif hit == 4:
                score += b1 + b2 + b3 + 1
                b1, b2, b3 = 0, 0, 0    # 싹쓸이 + 타자 점수
    # score의 최댓값을 보고 갱신을 한다.
    max_score = max(max_score, score)

print(max_score)


    # 총평? 일기? (의식의 흐름대로 그냥 써서 글이 정리가 되어있지 않음)
    # 분명 혼자 고민하는것도 중요하다라고 생각한다.
    # 그런데 지금 상태에서는 내 머리에 들어있는것도 별로 없는데
    # 고민만 몇시간 한다고 새로운 아이디어가 나오는것도 아니고
    # 나온다고 해도 최적화된 알고리즘일 확률은 1%로 안되는것같다.
    # 따라서 내 아이디어를 생각을 하고 코드로 구현을 해보되
    # 헷갈리거나 모르는 부분을 명확하게 AI한테 능동적으로 물어보는게 좋아보인다.
    # 그렇다고 절대 AI한테 이 문제 풀어달라고 하는것은
    # 도움이 되는 최선의 방법이라고 않는다고 생각한다.
    # 물론 잘 쓴 코드를 많이 보는것도 좋다라고 생각한다.
    # AI코드 또는 최적화 솔루션 코드들을 많이 보는것도 중요하다.
    # 하지만 지금 나에게 필요한것은 내가 필요한 부족한 부분만
    # 아는것이라고 생각한다.
    # 결국 최종목표는 코딩테스트에 나 스스로 최적의 코드를 생각할 줄 알아야
    # 한다는 것이다. 최적의 코드를 본적도 없는 사람이 그런 코드를 떠올릴 수가 없다.
    # 모두가 AI를 쓰는 시대에 같은 AI라는 굉장한 무기를 가지고
    # 어떻게 쓰는지에 따라서 효율성이 정말 크게 바뀔거라고 생각한다.
    # 이 문제로 생각의 흐름에 대해서 그리고 AI의 활용에 대해
    # 정말 많은것을 배웠다. 
    # 이렇게 내가 생각한것들은 다 정리를 하고 나중에 매주마다 모아서
    # AI한테 정리를 해달라고 하고 누적 복습을 해야겠다.

            